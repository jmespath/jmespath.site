expr      = ws (terminal / non-terminal) ws
root-expr = non-test / not / comparison
non-test  = subexpr / index / flatten / wildcard-index / filter /
            identifier / current-node / literal / root-multi-list /
            multi-hash / function / group / slice
group     = open-group expr close-group

; Insignificant whitespace is allowed around expr nodes and around the
; following structural tokens.
open-group      = ws "(" ws
close-group     = ws ")" ws
open-bracket    = ws "[" ws
close-bracket   = ws "]" ws
open-brace      = ws "{" ws
close-brace     = ws "}" ws
dot-separator   = ws "." ws
pipe-separator  = ws "|" ws
or-separator    = ws "||" ws
and-separator   = ws "&&" ws
name-separator  = ws ":" ws
value-separator = ws "," ws
lt              = ws "<" ws
lte             = ws "<=" ws
gt              = ws ">" ws
gte             = ws ">=" ws
eq              = ws "==" ws
ne              = ws "!=" ws
expref-token    = "&" ws
not-token       = "!" ws

; "&&" binds more tightly than "||"
; "||" binds more tightly than "|".
terminal     = pipe / or / and
non-terminal = root-expr / wildcard-values
pipe         = expr pipe-separator (non-terminal / or / and)
or           = (non-terminal / and) or-separator (non-terminal / or / and)
and          = non-terminal and-separator (non-terminal / and)

; subexpr handles most that descend into nodes.
subexpr            = object-subexpr / array-subexpr
object-subexpr     = object-subexpr-lhs dot-separator object-subexpr-rhs
object-subexpr-lhs = subexpr / index / flatten / wildcard-index /
                     filter / identifier / current-node / literal /
                     multi-hash / function / group / slice / wildcard-values
object-subexpr-rhs = identifier / multi-list / multi-hash / function /
                     wildcard-values
array-subexpr      = array-subexpr-lhs array-subexpr-rhs
array-subexpr-lhs  = subexpr / index / flatten / wildcard-index / filter /
                     identifier / current-node / literal / root-multi-list /
                     function / group / slice / wildcard-values / literal
array-subexpr-rhs  = index / slice / wildcard-index / flatten / filter

; Array related rules
index           = open-bracket number close-bracket
slice           = open-bracket *number name-separator
                               *number *(name-separator *number)
                               close-bracket
wildcard-index   = open-bracket "*" close-bracket
flatten          = open-bracket close-bracket
filter           = open-bracket "?" filter-condition close-bracket
filter-condition = not / non-test / terminal / comparison

not             = not-token (non-test / not)
comparison      = non-terminal comparator (non-test / not / wildcard-values)
comparator      = lt / lte / gt / gte / eq / ne

root-multi-list = open-bracket
                  (root-expr / multiple-values / terminal)
                  close-bracket
multi-list      = open-bracket (expr / multiple-values) close-bracket
multiple-values = expr 1*( value-separator expr )

multi-hash      = open-brace (keyval *(value-separator keyval)) close-brace
keyval          = identifier name-separator expr

function        = unquoted-string arg-list
arg-list        = open-group *1(arg *(value-separator arg)) close-group
arg             = expr / expref

expref          = expref-token expr
wildcard-values = "*"
current-node    = "@"

number            = *"-" 1*DIGIT
literal           = "`" 1*(unescaped-literal / escaped-literal) "`"
unescaped-literal = %x20-5f / %x61-10FFFF
                     ; Any character after and including space, but not `
escaped-literal   = escaped-char / (escape "`")
identifier        = unquoted-string / quoted-string
unquoted-string   = (ALPHA / "_") *(DIGIT / ALPHA / "_")
quoted-string     = DQUOTE 1*(unescaped-char / escaped-char) DQUOTE
unescaped-char    = %x20-21 / %x23-5B / %x5D-10FFFF
                     ; Any character other than "\"
escape            = %x5C             ; "\"
escaped-char      = escape (
                     %x22 /          ; "    quotation mark  U+0022
                     %x5C /          ; \    reverse solidus U+005C
                     %x2F /          ; /    solidus         U+002F
                     %x62 /          ; b    backspace       U+0008
                     %x66 /          ; f    form feed       U+000C
                     %x6E /          ; n    line feed       U+000A
                     %x72 /          ; r    carriage return U+000D
                     %x74 /          ; t    tab             U+0009
                     %x75 4HEXDIG )  ; uXXXX                U+XXXX

; Whitespace is Space, HTAB, LF, or CR
ws = *(%x20 / %x09 / %x0A / %x0D)
